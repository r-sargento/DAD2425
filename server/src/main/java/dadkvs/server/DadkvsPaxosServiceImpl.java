
package dadkvs.server;

import java.util.ArrayList;
import java.util.Iterator;

import dadkvs.util.CollectorStreamObserver;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxos.LearnReply;
import dadkvs.DadkvsPaxos.PhaseOneReply;
import dadkvs.DadkvsPaxos.PhaseOneRequest;
import dadkvs.DadkvsPaxos.PhaseTwoReply;
import dadkvs.DadkvsPaxos.PhaseTwoRequest;
import dadkvs.DadkvsPaxosServiceGrpc;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Random;

import com.google.common.collect.ArrayListMultimap;

import dadkvs.util.GenericResponseCollector;
import dadkvs.util.CollectorStreamObserver;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

public class DadkvsPaxosServiceImpl extends DadkvsPaxosServiceGrpc.DadkvsPaxosServiceImplBase {

    DadkvsServerState server_state;
    DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_paxos_stubs;

    //for concurrent acess
    private AtomicInteger timestamp;
    private ConcurrentHashMap<Integer, PaxosInstance> paxosInstances;

    public DadkvsPaxosServiceImpl(DadkvsServerState state, DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_paxos_stubs) {
        this.server_state = state;
        this.timestamp = new AtomicInteger(server_state.my_id);
        this.paxosInstances = new ConcurrentHashMap<>();
        this.async_paxos_stubs = async_paxos_stubs;
    }

    @Override
    public void phaseone(DadkvsPaxos.PhaseOneRequest request,
            StreamObserver<DadkvsPaxos.PhaseOneReply> responseObserver) {

        this.server_state.checkAndRunSlowMode();

        // for debug purposes
        System.out.println("Receive phase1 request: " + request);

        int config = request.getPhase1Config();
        int index = request.getPhase1Index();
        int requestTimestamp = request.getPhase1Timestamp();

        PaxosInstance instance = paxosInstances.computeIfAbsent(index, k -> new PaxosInstance());

        PhaseOneReply reply;
        if (requestTimestamp > instance.getHighestTimestamp()) {
            instance.setHighestTimestamp(requestTimestamp);
            reply = PhaseOneReply.newBuilder()
                .setPhase1Config(config)
                .setPhase1Index(index)
                .setPhase1Accepted(true)
                .setPhase1Value(instance.getAcceptedValue())
                .setPhase1Timestamp(instance.getAcceptedTimestamp())
                .build();
        } else {
            reply = PhaseOneReply.newBuilder()
                .setPhase1Config(config)
                .setPhase1Index(index)
                .setPhase1Accepted(false)
                .build();
        }

        responseObserver.onNext(reply);
        responseObserver.onCompleted();

    }

    @Override
    public void phasetwo(DadkvsPaxos.PhaseTwoRequest request,
            StreamObserver<DadkvsPaxos.PhaseTwoReply> responseObserver) {

        this.server_state.checkAndRunSlowMode();

        // for debug purposes
        System.out.println("Receive phase two request: " + request);

        int config = request.getPhase2Config();
        int index = request.getPhase2Index();
        int value = request.getPhase2Value();
        int requestTimestamp = request.getPhase2Timestamp();

        PaxosInstance instance = paxosInstances.get(index);

        PhaseTwoReply reply;
        if (requestTimestamp >= instance.getHighestTimestamp()) {
            instance.setAcceptedValue(value);
            instance.setAcceptedTimestamp(requestTimestamp);
            reply = PhaseTwoReply.newBuilder()
                .setPhase2Config(config)
                .setPhase2Index(index)
                .setPhase2Accepted(true)
                .build();
        } else {
            reply = PhaseTwoReply.newBuilder()
                .setPhase2Config(config)
                .setPhase2Index(index)
                .setPhase2Accepted(false)
                .build();
        }

        responseObserver.onNext(reply);
        responseObserver.onCompleted();

    }

    @Override
    public void learn(DadkvsPaxos.LearnRequest request, StreamObserver<DadkvsPaxos.LearnReply> responseObserver) {
        
        this.server_state.checkAndRunSlowMode();
        
        // for debug purposes
        System.out.println("Receive learn request: " + request);

        int config = request.getLearnconfig();
        int index = request.getLearnindex();
        int value = request.getLearnvalue();
        int learnTimestamp = request.getLearntimestamp();

        PaxosInstance instance = paxosInstances.computeIfAbsent(index, k -> new PaxosInstance());
        instance.setDecidedValue(value);
        instance.setDecidedTimestamp(learnTimestamp);

        // Execute the decided value (request)
        System.out.println("Executing request for instance " + index);
        executeRequest(index, value);

        LearnReply reply = LearnReply.newBuilder()
            .setLearnconfig(config)
            .setLearnindex(index)
            .setLearnaccepted(true)
            .build();

        responseObserver.onNext(reply);
        responseObserver.onCompleted();

    }

    private void executeRequest(int index, int value) {
        server_state.executeDecidedValue(index, value);
    }

    public void startPaxosInstance(int index, int value) {
        int currentTimestamp = timestamp.getAndAdd(3);
        PhaseOneRequest request = PhaseOneRequest.newBuilder()
            .setPhase1Config(0)
            .setPhase1Index(index)
            .setPhase1Timestamp(currentTimestamp)
            .build();
        
        
        ArrayList<PhaseOneReply> replies = new ArrayList<>();
        GenericResponseCollector<PhaseOneReply> collector = new GenericResponseCollector<>(replies, 3);
        // Send Phase 1 messages to all acceptors in config
        for (int i = 0; i < 3; i++){
            async_paxos_stubs[i].phaseone(request, new CollectorStreamObserver<PhaseOneReply>(collector));
        }
        collector.waitForTarget(2); //wait for majority of replies in acceptors

        //iterate over replies and pick value
        int lastRecentValueTimestamp = -1;
        for (PhaseOneReply reply : replies) {
            if (reply.getPhase1Accepted()) {
                //check if value return is more recent than mine
                if (reply.getPhase1Value() != -1 && reply.getPhase1Timestamp() > lastRecentValueTimestamp) {
                    //update value
                    lastRecentValueTimestamp = reply.getPhase1Timestamp();
                    value = reply.getPhase1Value();
                    startPaxosInstance(index+1, value); // go try to do paxos for next slot
                    //return here??? maybe not to be able to finish current paxos
                }
            }else{
                //if not accepted, start new instance
                timestamp.addAndGet(3); //increment timestamp by num of servers
                Random random = new Random();
                int randomSleepTime = random.nextInt(3000);
                try {
                    // Sleep for the random duration
                    Thread.sleep(randomSleepTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                startPaxosInstance(index, value);
                return;
            }
        }
        
        // Send Phase 2 messages to all acceptors
        PhaseTwoRequest phaseTwoRequest = PhaseTwoRequest.newBuilder()
            .setPhase2Config(0)
            .setPhase2Index(index)
            .setPhase2Value(value)
            .setPhase2Timestamp(currentTimestamp)
            .build();

        ArrayList<PhaseTwoReply> phaseTwoReplies = new ArrayList<>();
        GenericResponseCollector<PhaseTwoReply> phaseTwoCollector = new GenericResponseCollector<>(phaseTwoReplies, 3);
        for (int i = 0; i < 3; i++){
            async_paxos_stubs[i].phasetwo(phaseTwoRequest, new CollectorStreamObserver<PhaseTwoReply>(phaseTwoCollector));
        }
        phaseTwoCollector.waitForTarget(2);

        for (PhaseTwoReply reply : phaseTwoReplies) {
            if (!reply.getPhase2Accepted()) {
                //if not accepted, start new instance
                timestamp.addAndGet(3); //increment timestamp by num of servers
                Random random = new Random();
                int randomSleepTime = random.nextInt(3000);
                try {
                    // Sleep for the random duration
                    Thread.sleep(randomSleepTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                startPaxosInstance(index, value);
                return;
            }
        }

        //Send learn message to all replicas
        DadkvsPaxos.LearnRequest learnRequest = DadkvsPaxos.LearnRequest.newBuilder()
            .setLearnconfig(0)
            .setLearnindex(index)
            .setLearnvalue(value)
            .setLearntimestamp(currentTimestamp)
            .build();

        ArrayList<LearnReply> learnReplies = new ArrayList<>();
        GenericResponseCollector<LearnReply> learnCollector = new GenericResponseCollector<>(learnReplies, 5);
        for (int i = 0; i < 5; i++){
            async_paxos_stubs[i].learn(learnRequest, new CollectorStreamObserver<LearnReply>(learnCollector));
        }
        learnCollector.waitForTarget(3);

    }

}
